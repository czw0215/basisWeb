<!DOCTYPE html>
<html>
<head>
	<title></title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
	<link rel="stylesheet" type="text/css" href="../css/base.css"/>
	<script src="../js/jquery-1.8.3.min.js" type="text/javascript"></script>
	<script>

	//加载完文档，执行下面代码
	$(function(){
		var inputsType = ["dom","方法名","dom"];
		var inputsDefaulteValue = ["A","append","B"];
		var domA = $(".A")[0];
		//创建盒子B
		var domB = $("<div class='A-son B'>.A-son .B</div>");
		var myForm = $("#myForm");
		var inputString = "";
		//循环产生input标签
		for (var i = 0 ; i < inputsType.length;  i++) {
			inputString += "<label for="+inputsType[i]+">"+inputsType[i]+": </label><input type='text' id="+inputsType[i]+" class='inputT' value="+inputsDefaulteValue[i]+" /> ";
		}
		inputString +="<input type='button' id='mySubmit' value='提交'/>" 
		myForm.html(inputString);
		parseFunction(inputsDefaulteValue,domA,domB);
		//提交时收集input的value
		function showChange(domA){
			var inputsValue = [];
			$(".inputT").each(function(index){
				inputsValue[index] = this.value;
			});
			//alert(inputsValue);
			parseFunction(inputsValue,domA,domB)
		}

		//解析inputs然后执行此属性
		function parseFunction(array,A,B){
			//myDiv[a[0]]("title","red");
			var result = null;
			//alert(array[1]);
			//查看有多少参数，根据参数个数，调用函数
			switch(2){
				case 0:
				$(eval(array[0]))[array(1)](eval(array[2]));
				break;
				case 1:
				myDiv[array[0]](eval(array[2]));
				break;
				case 2:
				//先清空A和content
				$(".content").html(A);
				$(A).html(".A");
				$(eval(array[0]))[array[1]](eval(array[2]));
				break;
				default:
				alert("参数个数只支持0-2个");
			}
		}

		//为提交注册处理是事件
		$("#mySubmit").bind("click",function(){
			showChange(domA);
		});
	
	});
	</script>
</head> 
<body>
	<div class="content">
		<div class='A content-son'>.A</div>
	</div>
	<form id="myForm">		
	</form>
	<p>本例中参数中如果为字符串，请加字符串</p>
	<table class="explanation">
		<thead>
			<tr>
				<th class="explanation_left">方法</th><th class="explanation_right">本例支持的演示</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td class="explanation_left">wrap(html|element|fn)</td><td class="explanation_right">把所有匹配的元素用其他元素的结构化标记包裹起来。</td>
			</tr>
			<tr>
				<td class="explanation_left">unwrap()</td><td class="explanation_right">这个方法将移出元素的父元素。这能快速取消 .wrap()方法的效果。匹配的元素（以及他们的同辈元素）会在DOM结构上替换他们的父元素。</td>
			</tr>
			<tr>
				<td class="explanation_left">wrapAll(html|ele)</td><td class="explanation_right">将所有匹配的元素用单个元素包裹起来</td>
			</tr>
			<tr>
				<td class="explanation_left">wrapInner(htm|element|fnl)</td><td class="explanation_right">将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来</td>
			</tr>
			<tr>
				<td class="explanation_left">replaceWith(content|fn)</td><td class="explanation_right">将所有匹配的元素替换成指定的HTML或DOM元素。</td>
			</tr>
			<tr>
				<td class="explanation_left">empty()</td><td class="explanation_right">删除匹配的元素集合中所有的子节点。</td>
			</tr>
			<tr>
				<td class="explanation_left">remove([expr])</td><td class="explanation_right">expr String 用于筛选元素的jQuery表达式</td>
			</tr>
			<tr>
				<td class="explanation_left">detach([expr])</td><td class="explanation_right">用于筛选元素的jQuery表达式这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。</td>
			</tr>
			<tr>
				<td class="explanation_left">clone([Even[,deepEven]])</td><td class="explanation_right">克隆匹配的DOM元素并且选中这些克隆的副本。<span class="emphasize">本例不能演示</span></td>
			</tr>
		</tbody>
	</table>
	<footer id="mypage_footer">
		<div class="mypage_footer_right">
			<ul class="footer_nav_ul">
				<li><a href="handleDocument-1.html" target="_self">上一页</a></li>
				<li><a href="../index.html" target="_self">首页</a></li>
				<li><a href="show-1.html" target="_self">下一页</a></li>
			</ul>
		</div>
	</footer>
</body>
</html>